<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ìš°ì£¼ì „ìŸ v0.0.19.5</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Malgun Gothic', sans-serif; color: white; -webkit-tap-highlight-color: transparent; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 10; touch-action: none; }
        #fixed-ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; pointer-events: none; }
        .score-container { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-between; padding: 0 15px; box-sizing: border-box; }
        .score-box { pointer-events: auto; font-size: 13px; font-weight: bold; padding: 10px; background: rgba(0,0,0,0.85); border-radius: 8px; border: 1px solid #ffffff33; line-height: 1.5; min-width: 150px; }
        #timer-display { position: absolute; top: 85px; left: 50%; transform: translateX(-50%); font-size: 32px; font-weight: bold; color: #ff3e3e; text-shadow: 0 0 10px #000; }
        #turn-msg { position: absolute; top: 135px; left: 50%; transform: translateX(-50%); font-size: 18px; font-weight: bold; color: #00ffcc; text-shadow: 0 0 10px #000; width: 100%; text-align: center; }
        #bottom-ctrl { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: none; gap: 10px; background: rgba(0,0,0,0.85); padding: 10px 20px; border-radius: 50px; border: 1px solid #00ffcc; pointer-events: auto; z-index: 200; }
        .ctrl-btn { color: white; background: rgba(255,255,255,0.1); border: 1px solid #3498db; padding: 6px 15px; border-radius: 20px; cursor: pointer; font-size: 12px; }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; z-index: 1000; background: rgba(0,0,0,0.9); pointer-events: auto; }
        .rank-card { background: #0f0f1e; padding: 25px; border-radius: 20px; border: 2px solid #3498db; width: 85%; max-width: 350px; text-align: center; }
        .start-btn { padding: 15px; font-size: 18px; font-weight: bold; background: #3498db; color: #fff; border: none; border-radius: 12px; cursor: pointer; width: 100%; margin-top: 10px; box-shadow: 0 0 15px #3498db; }
        select, input[type=range] { width: 100%; margin-top: 5px; background: #111; color: white; border: 1px solid #3498db; padding: 8px; border-radius: 5px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <audio id="bgm" loop preload="auto"><source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-8.mp3" type="audio/mpeg"></audio>
    <audio id="snd-select" preload="auto"><source src="https://assets.mixkit.co/active_storage/sfx/2571/2571-preview.mp3" type="audio/mpeg"></audio>
    <audio id="snd-connect" preload="auto"><source src="https://assets.mixkit.co/active_storage/sfx/2568/2568-preview.mp3" type="audio/mpeg"></audio>
    <audio id="snd-capture-player" preload="auto"><source src="https://assets.mixkit.co/active_storage/sfx/1435/1435-preview.mp3" type="audio/mpeg"></audio>
    <audio id="snd-capture-ai" preload="auto"><source src="https://assets.mixkit.co/active_storage/sfx/2511/2511-preview.mp3" type="audio/mpeg"></audio>
    <audio id="snd-end" preload="auto"><source src="https://assets.mixkit.co/active_storage/sfx/1433/1433-preview.mp3" type="audio/mpeg"></audio>

    <div id="rule-screen" class="overlay">
        <div class="rank-card">
            <h2 style="color:#00ffcc; margin-bottom:5px;">ğŸŒ¬ï¸ ë°”ëŒì˜ í›„ì˜ˆ</h2>
            <p style="font-size:12px; color:#aaa; margin-bottom:15px;">v0.0.19.5 ì „ëµ ìŠ¤ì½”ì–´ë§</p>
            <div style="text-align:left; padding:15px; font-size:13px; line-height:1.6;">
                ğŸ¯ <b>ì ìˆ˜ ë£°:</b><br>
                - 3ë³€ ìê¸° ì„ : <b>100%</b> ì ìˆ˜<br>
                - 2ë³€ ìê¸° ì„ : <b>80%</b> ì ìˆ˜<br>
                - 1ë³€ ìê¸° ì„ : <b>50%</b> ì ìˆ˜<br>
                âš ï¸ <b>ì‹œê°„ íŒ¨ë„í‹°:</b> 10ì´ˆ ì´ˆê³¼ ì‹œ ëˆ„ì  ê°ì !
            </div>
            <button class="start-btn" onclick="startWithSound()">í•¨ëŒ€ ì¶œê²©</button>
        </div>
    </div>

    <div id="result-screen" class="overlay" style="display:none;">
        <div class="rank-card">
            <h1 style="color:#ff3e3e; margin-bottom:10px;">ì‘ì „ ì¢…ë£Œ</h1>
            <h2 id="final-score" style="color:white; font-size: 15px; line-height: 1.8; margin-bottom:20px;"></h2>
            <h2 id="winner-text" style="color:#00ffcc; margin-bottom:20px;"></h2>
            <button class="start-btn" onclick="location.reload()">ìƒˆë¡œìš´ ì „ì„ ìœ¼ë¡œ</button>
        </div>
    </div>

    <div id="fixed-ui">
        <div class="score-container">
            <div class="score-box" style="color:#2ecc71; border-color:#2ecc71;">ì—°ë§¹ ì´ ë³‘ë ¥ :<br><span id="s1">0</span>ì–µ ëª…</div>
            <div class="score-box" style="color:#e74c3c; border-color:#e74c3c; text-align:right;">ì œêµ­ ì´ ë³‘ë ¥ :<br><span id="s2">0</span>ì–µ ëª…</div>
        </div>
        <div id="timer-display">10</div>
        <div id="turn-msg">ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...</div>
        <div id="bottom-ctrl">
            <button class="ctrl-btn" onclick="toggleBGM()">ğŸµ ì£¼íŒŒìˆ˜</button>
            <button class="ctrl-btn" onclick="location.reload()">í‡´ê°</button>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const bgImg = new Image();
    bgImg.src = 'https://r.jina.ai/i/5688686e04d44439832267675e03222e';
    let bgLoaded = false; bgImg.onload = () => { bgLoaded = true; };

    let points=[], lines=[], triangles=[], selectedPoint=null, mousePos={x:0,y:0}, isDragging=false;
    let currentPlayer=1, scores={1:0, 2:0}, effects=[], isGameOver = false, turnTime = 10, timerInterval;
    let penaltyCount = {1:0, 2:0}, gameStarted = false;
    let aiAnim = { active: false, startP: null, targetP: null, progress: 0 };

    function playSnd(id, vol=0.5) {
        const s = document.getElementById(id);
        if(s) { s.currentTime = 0; s.volume = vol; s.play().catch(()=>{}); }
    }

    function startWithSound() {
        playSnd('bgm', 0.2);
        ['snd-select', 'snd-connect', 'snd-capture-player', 'snd-capture-ai', 'snd-end'].forEach(id => {
            const s = document.getElementById(id); s.play().then(()=> { s.pause(); s.currentTime=0; }).catch(()=>{});
        });
        document.getElementById('rule-screen').style.display = 'none';
        document.getElementById('bottom-ctrl').style.display = 'flex';
        startGame(25);
    }

    function startGame(count) {
        resize();
        points = []; lines = []; triangles = []; scores = {1:0, 2:0}; penaltyCount = {1:0, 2:0};
        currentPlayer = Math.random() > 0.5 ? 1 : 2; 
        isGameOver = false; gameStarted = true;
        points.push({ x: canvas.width/2, y: canvas.height/2, isCore: true });
        for(let i=0; i<count-1; i++) {
            let nx, ny, ok;
            do {
                nx = 50 + Math.random() * (canvas.width - 100);
                ny = 150 + Math.random() * (canvas.height - 250);
                ok = points.every(p => Math.hypot(p.x - nx, p.y - ny) > 65);
            } while(!ok);
            points.push({ x: nx, y: ny, isCore: false });
        }
        updateTurnMsg(); startTimer(); updateUI(); 
        requestAnimationFrame(drawLoop);
        if(currentPlayer === 2) setTimeout(aiThink, 1500);
    }

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);

    function startTimer() {
        if(isGameOver) return;
        clearInterval(timerInterval); turnTime = 10;
        document.getElementById('timer-display').innerText = turnTime;
        timerInterval = setInterval(() => {
            turnTime--; 
            document.getElementById('timer-display').innerText = turnTime;
            if(turnTime <= 0) {
                // ê°•ë ¥í•œ ëˆ„ì  íŒ¨ë„í‹° ì‹œìŠ¤í…œ
                penaltyCount[currentPlayer]++;
                let penaltyValue = penaltyCount[currentPlayer] * 50; 
                scores[currentPlayer] = Math.max(0, scores[currentPlayer] - penaltyValue);
                effects.push({x: canvas.width/2, y: 150, text: `í†µì‹  ë‘ì ˆ! -${penaltyValue}ì–µ ì†ì‹¤`, color: "#ff3e3e"});
                playSnd('snd-capture-ai', 0.5); // ê²½ê³ ìŒ ëŒ€ìš©
                updateUI(); nextTurn();
            }
        }, 1000);
    }

    function attemptMove(p1, p2) {
        lines.push({p1, p2, player: currentPlayer}); 
        playSnd('snd-connect', 0.6);
        let found = false;

        points.forEach(p3 => {
            if(p3 === p1 || p3 === p2) return;
            const l1 = lines.find(l => (l.p1===p1 && l.p2===p3) || (l.p1===p3 && l.p2===p1));
            const l2 = lines.find(l => (l.p1===p2 && l.p2===p3) || (l.p1===p3 && l.p2===p2));
            const l3 = lines.find(l => (l.p1===p1 && l.p2===p2) || (l.p1===p2 && l.p2===p1)); // ë°©ê¸ˆ ê·¸ì€ ì„ 

            if(l1 && l2 && !triangles.some(t => [t.p1,t.p2,t.p3].every(p => [p1,p2,p3].includes(p)))) {
                triangles.push({p1, p2, p3, player: currentPlayer});
                
                // ì „ëµì  ì ìˆ˜ ê³„ì‚° ë¡œì§
                let myLines = [l1, l2, l3].filter(l => l.player === currentPlayer).length;
                let multiplier = 1.0;
                if(myLines === 2) multiplier = 0.8;
                if(myLines === 1) multiplier = 0.5;

                let baseTroop = Math.floor(Math.abs((p1.x*(p2.y-p3.y) + p2.x*(p3.y-p1.y) + p3.x*(p1.y-p2.y)) / 100)) + 50; 
                let finalTroop = Math.floor(baseTroop * multiplier);
                
                scores[currentPlayer] += finalTroop; found = true;
                effects.push({x: (p1.x+p2.x+p3.x)/3, y: (p1.y+p2.y+p3.y)/3, text: `${finalTroop}ì–µ (${Math.round(multiplier*100)}%)`, color: currentPlayer==1?"#2ecc71":"#e74c3c"});
                playSnd(currentPlayer === 1 ? 'snd-capture-player' : 'snd-capture-ai', 0.7);
            }
        });

        if(!found) nextTurn(); else startTimer();
        updateUI(); checkGameOver();
    }

    function nextTurn() { 
        if(isGameOver) return;
        currentPlayer = currentPlayer === 1 ? 2 : 1; 
        updateTurnMsg(); startTimer(); updateUI(); 
        if(currentPlayer === 2) setTimeout(aiThink, 1200); 
    }

    function aiThink() {
        if(isGameOver || currentPlayer !== 2) return;
        let pss = [];
        for(let i=0; i<points.length; i++) {
            for(let j=i+1; j<points.length; j++) {
                if(canConnect(points[i], points[j])) {
                    let score = 1;
                    points.forEach(p3 => {
                        if(p3 === points[i] || p3 === points[j]) return;
                        const hasL1 = lines.some(l => (l.p1===points[i] && l.p2===p3) || (l.p1===p3 && l.p2===points[i]));
                        const hasL2 = lines.some(l => (l.p1===points[j] && l.p2===p3) || (l.p1===p3 && l.p2===points[j]));
                        if(hasL1 && hasL2) score = 10; // ì¸ê³µì§€ëŠ¥ë„ ì‚¼ê°í˜• ìš°ì„ 
                    });
                    pss.push({p1: points[i], p2: points[j], score});
                }
            }
        }
        if(pss.length > 0) {
            pss.sort((a, b) => b.score - a.score);
            let topTier = pss.filter(p => p.score === pss[0].score);
            let choice = topTier[Math.floor(Math.random()*topTier.length)];
            aiAnim.startP = choice.p1; aiAnim.targetP = choice.p2; aiAnim.progress = 0; aiAnim.active = true;
        } else nextTurn();
    }

    function canConnect(p1, p2) {
        if(!p1 || !p2 || p1 === p2) return false;
        if(lines.some(l => (l.p1 === p1 && l.p2 === p2) || (l.p1 === p2 && l.p2 === p1))) return false;
        const isPass = points.some(p => {
            if (p === p1 || p === p2) return false;
            const d = Math.abs((p2.y - p1.y) * p.x - (p2.x - p1.x) * p.y + p2.x * p1.y - p2.y * p1.x) / Math.hypot(p2.y - p1.y, p2.x - p1.x);
            const dot = (p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y);
            return d < 8 && dot >= 0 && dot <= (Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        });
        if(isPass) return false;
        const intersect = (a,b,c,d) => {
            const cp = (p1,p2,p3) => (p2.x-p1.x)*(p3.y-p1.y)-(p2.y-p1.y)*(p3.x-p1.x);
            const r1 = cp(a,b,c), r2 = cp(a,b,d), r3 = cp(c,d,a), r4 = cp(c,d,b);
            return (((r1 > 0 && r2 < 0) || (r1 < 0 && r2 > 0)) && ((r3 > 0 && r4 < 0) || (r3 < 0 && r4 > 0)));
        };
        return !lines.some(l => intersect(p1, p2, l.p1, l.p2));
    }

    function checkGameOver() {
        let moves = 0;
        for(let i=0; i<points.length; i++) for(let j=i+1; j<points.length; j++) if(canConnect(points[i], points[j])) moves++;
        if(moves === 0 && gameStarted) {
            isGameOver = true; clearInterval(timerInterval);
            playSnd('snd-end', 0.8);
            document.getElementById('final-score').innerHTML = `ì—°ë§¹ ë³‘ë ¥: ${scores[1].toLocaleString()}ì–µ ëª…<br>ì œêµ­ ë³‘ë ¥: ${scores[2].toLocaleString()}ì–µ ëª…`;
            document.getElementById('winner-text').innerText = scores[1] > scores[2] ? "ìŠ¹ë¦¬! í–‰ì„±ì„ íƒˆí™˜í–ˆìŠµë‹ˆë‹¤!" : "íŒ¨ë°°... ì„±ê³„ê°€ í•¨ë½ë˜ì—ˆìŠµë‹ˆë‹¤.";
            document.getElementById('result-screen').style.display = 'flex';
        }
    }

    function updateTurnMsg() {
        const msg = document.getElementById('turn-msg');
        msg.innerText = currentPlayer === 1 ? "ğŸŒ¬ï¸ í’ì˜ˆ ì—°ë§¹ ì‘ì „ ì‹œê°„" : "ğŸ¤– ì œêµ­êµ° ë³‘ë ¥ ì´ë™ ì¤‘";
        msg.style.color = currentPlayer === 1 ? "#2ecc71" : "#e74c3c";
    }

    function updateUI() { 
        document.getElementById('s1').innerText = scores[1].toLocaleString(); 
        document.getElementById('s2').innerText = scores[2].toLocaleString(); 
    }

    function toggleBGM() { const b = document.getElementById('bgm'); if(b.paused) b.play(); else b.pause(); }

    function drawLoop() {
        if(!gameStarted) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if(bgLoaded) ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
        
        triangles.forEach(t => {
            ctx.beginPath(); ctx.moveTo(t.p1.x, t.p1.y); ctx.lineTo(t.p2.x, t.p2.y); ctx.lineTo(t.p3.x, t.p3.y); ctx.closePath();
            ctx.fillStyle = t.player === 1 ? 'rgba(46, 204, 113, 0.4)' : 'rgba(231, 76, 60, 0.4)';
            ctx.fill(); ctx.strokeStyle = t.player === 1 ? '#2ecc71' : '#e74c3c'; ctx.stroke();
        });

        if(isDragging && selectedPoint) {
            ctx.beginPath(); ctx.moveTo(selectedPoint.x, selectedPoint.y); ctx.lineTo(mousePos.x, mousePos.y);
            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)"; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
        }

        if(aiAnim.active) {
            aiAnim.progress += 0.05;
            let cx = aiAnim.startP.x + (aiAnim.targetP.x - aiAnim.startP.x) * aiAnim.progress;
            let cy = aiAnim.startP.y + (aiAnim.targetP.y - aiAnim.startP.y) * aiAnim.progress;
            ctx.beginPath(); ctx.moveTo(aiAnim.startP.x, aiAnim.startP.y); ctx.lineTo(cx, cy);
            ctx.strokeStyle = "rgba(231, 76, 60, 0.7)"; ctx.setLineDash([5, 5]); ctx.lineWidth = 2; ctx.stroke(); ctx.setLineDash([]);
            if(aiAnim.progress >= 1) { aiAnim.active = false; attemptMove(aiAnim.startP, aiAnim.targetP); }
        }

        lines.forEach(l => {
            ctx.beginPath(); ctx.moveTo(l.p1.x, l.p1.y); ctx.lineTo(l.p2.x, l.p2.y);
            ctx.strokeStyle = l.player === 1 ? '#2ecc71' : '#e74c3c'; ctx.lineWidth = 2; ctx.stroke();
        });

        points.forEach(p => {
            ctx.font = p.isCore ? "40px Arial" : "25px Arial"; ctx.textAlign = "center";
            ctx.fillStyle = "white"; ctx.fillText(p.isCore ? "â˜€ï¸" : "âœ¨", p.x, p.y+10);
            if(selectedPoint === p) { ctx.strokeStyle = "#00ffcc"; ctx.lineWidth = 2; ctx.strokeRect(p.x-22, p.y-22, 44, 44); }
        });

        for(let i = effects.length - 1; i >= 0; i--) {
            let e = effects[i]; ctx.fillStyle = e.color; ctx.font = "bold 16px Arial"; ctx.textAlign = "center";
            ctx.fillText(e.text, e.x, e.y); e.y -= 1.0; if(e.y < 0) effects.splice(i, 1);
        }
        requestAnimationFrame(drawLoop);
    }

    const hStart = (x, y) => { 
        if(currentPlayer !== 1 || isGameOver || aiAnim.active) return; 
        const p = points.find(pt => Math.hypot(pt.x - x, pt.y - y) < 40); 
        if(p) { selectedPoint = p; isDragging = true; mousePos = {x, y}; playSnd('snd-select', 0.4); } 
    };
    const hMove = (x, y) => { if(isDragging) mousePos = {x, y}; };
    const hEnd = (x, y) => { 
        if(!isDragging) return; 
        const p = points.find(pt => Math.hypot(pt.x - x, pt.y - y) < 40); 
        if(p && p !== selectedPoint && canConnect(selectedPoint, p)) attemptMove(selectedPoint, p); 
        selectedPoint = null; isDragging = false; 
    };

    canvas.addEventListener('mousedown', e => hStart(e.clientX, e.clientY));
    window.addEventListener('mousemove', e => hMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', e => hEnd(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', e => { hStart(e.touches[0].clientX, e.touches[0].clientY); e.preventDefault(); }, {passive:false});
    window.addEventListener('touchmove', e => hMove(e.touches[0].clientX, e.touches[0].clientY));
    window.addEventListener('touchend', e => { const t = e.changedTouches[0]; hEnd(t.clientX, t.clientY); });
</script>
</body>
</html>
