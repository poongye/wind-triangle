<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë°”ëŒì˜ ì‚¼ê°í˜• - poongye v0.0.2</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0b0e14; font-family: 'Malgun Gothic', sans-serif; color: white; touch-action: none; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(11, 14, 20, 0.95); z-index: 100; text-align: center; padding: 20px; box-sizing: border-box; }
        .rule-card { background: rgba(44, 62, 80, 0.8); padding: 20px; border-radius: 20px; border: 2px solid #f1c40f; max-width: 400px; line-height: 1.6; pointer-events: auto; position: relative; }
        .rule-list { text-align: left; display: inline-block; margin: 15px 0; font-size: 15px; color: #ecf0f1; }
        h1 { font-size: 32px; color: #f1c40f; text-shadow: 0 0 20px #f1c40f; margin-bottom: 20px; }
        .menu-btn { padding: 15px; margin: 8px; font-size: 18px; font-weight: bold; border: 2px solid #2ecc71; background: transparent; color: #2ecc71; border-radius: 50px; cursor: pointer; transition: 0.2s; width: 80%; max-width: 300px; pointer-events: auto; }
        .menu-btn:hover { background: #2ecc71; color: white; }
        .version-tag { position: absolute; bottom: 10px; right: 20px; font-size: 12px; color: rgba(255, 255, 255, 0.4); font-family: monospace; }
        
        #ingame-ui { position: absolute; top: 20px; left: 0; width: 100%; pointer-events: none; display: none; justify-content: space-between; padding: 0 20px; box-sizing: border-box; z-index: 50; }
        .score-box { font-size: 18px; font-weight: bold; }
        .p1-ui { color: #2ecc71; } .p2-ui { color: #e74c3c; }
        .turn-box { font-size: 30px; font-weight: 900; padding: 15px; border-radius: 10px; border: 2px solid transparent; }
        .active-turn { background: white; color: black; box-shadow: 0 0 15px white; }
    </style>
</head>
<body>

    <audio id="bgm" loop><source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg"></audio>

    <div id="rule-screen" class="overlay">
        <h1>ğŸŒ¬ï¸ ë°”ëŒì˜ ì‚¼ê°í˜•</h1>
        <div class="rule-card">
            <h2>ğŸ“œ ê²Œì„ ê·œì¹™</h2>
            <ul class="rule-list">
                <li>ğŸ“ ë‘ ì ì„ ì—°ê²°í•˜ì—¬ <b>ì„ </b>ì„ ê¸‹ìŠµë‹ˆë‹¤.</li>
                <li>ğŸš« ì„ ì€ ë‹¤ë¥¸ ì„ ì´ë‚˜ ì ì„ í†µê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</li>
                <li>ğŸ“ ì‚¼ê°í˜•ì„ ë§Œë“¤ë©´ <b>1ì </b> íšë“ í›„ <b>ì¶”ê°€ í„´!</b></li>
            </ul>
            <div class="version-tag">v0.0.2</div>
        </div>
        <button class="menu-btn" onclick="showDifficulty()">ê²Œì„ ì‹œì‘í•˜ê¸°</button>
    </div>

    <div id="difficulty-screen" class="overlay" style="display:none;">
        <h1>ë‚œì´ë„ ì„ íƒ</h1>
        <button class="menu-btn" onclick="selectDifficulty('easy')">EASY</button>
        <button class="menu-btn btn-normal" onclick="selectDifficulty('normal')">NORMAL</button>
        <button class="menu-btn btn-hard" onclick="selectDifficulty('hard')">HARD</button>
    </div>

    <div id="count-screen" class="overlay" style="display:none;">
        <h1>ì ì˜ ê°œìˆ˜</h1>
        <button class="menu-btn btn-count" onclick="selectPointCount(10)">10ê°œ</button>
        <button class="menu-btn btn-count" onclick="selectPointCount(20)">20ê°œ</button>
        <button class="menu-btn btn-count" onclick="selectPointCount(30)">30ê°œ</button>
    </div>

    <div id="turn-decide-screen" class="overlay" style="display:none;">
        <h2 id="turn-title">ì„ ê³µ ê²°ì • ì¤‘...</h2>
        <div style="display: flex; gap: 20px; margin-top: 20px;">
            <div id="slot-p1" class="turn-box p1-ui">USER</div>
            <div id="slot-p2" class="turn-box p2-ui">AI</div>
        </div>
    </div>

    <div id="ingame-ui">
        <div class="score-box p1-ui">USER: <span id="s1">0</span></div>
        <div id="mid-msg" style="text-align: center;"></div>
        <div class="score-box p2-ui">AI: <span id="s2">0</span></div>
    </div>

    <div id="game-over-screen" class="overlay" style="display:none;">
        <h1 style="color: #f1c40f;">GAME OVER</h1>
        <div id="winner-msg" style="font-size: 20px; margin-bottom: 20px;"></div>
        <button class="menu-btn" onclick="location.reload()">ë‹¤ì‹œ í•˜ê¸°</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let audioCtx;
    
    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function resize() { 
        canvas.width = window.innerWidth; canvas.height = window.innerHeight; 
        ctx.fillStyle = "#0b0e14"; ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize); resize();

    let points = [], lines = [], triangles = [], selectedPoint = null, currentPlayer = 0, scores = {1:0, 2:0}, isGameOver = false, aiLevel;
    let mousePos = { x: 0, y: 0 }, aiAnimating = false, aiStartPoint, aiEndPoint, aiAnimProgress = 0;
    
    // ì´í™íŠ¸ ê´€ë¦¬ìš© ë°°ì—´
    let scoreEffects = [];

    function showDifficulty() {
        initAudio();
        document.getElementById('rule-screen').style.display = 'none';
        document.getElementById('difficulty-screen').style.display = 'flex';
    }

    function selectDifficulty(l) { 
        aiLevel = l; try { document.getElementById('bgm').play(); } catch(e) {}
        document.getElementById('difficulty-screen').style.display = 'none'; 
        document.getElementById('count-screen').style.display = 'flex'; 
    }

    function selectPointCount(c) { 
        document.getElementById('count-screen').style.display = 'none'; 
        decideTurn(c); 
    }

    function decideTurn(pointCount) {
        document.getElementById('turn-decide-screen').style.display = 'flex';
        let count = 0, currentSlot = 1;
        const interval = setInterval(() => {
            document.getElementById('slot-p1').classList.toggle('active-turn', currentSlot === 1);
            document.getElementById('slot-p2').classList.toggle('active-turn', currentSlot === 2);
            currentSlot = currentSlot === 1 ? 2 : 1;
            if (++count > 15) {
                clearInterval(interval);
                currentPlayer = Math.random() > 0.5 ? 1 : 2;
                document.getElementById('slot-p1').classList.toggle('active-turn', currentPlayer === 1);
                document.getElementById('slot-p2').classList.toggle('active-turn', currentPlayer === 2);
                document.getElementById('turn-title').innerText = (currentPlayer === 1 ? "USER" : "AI") + " ì„ ê³µ!";
                setTimeout(() => startGame(pointCount), 1000);
            }
        }, 80);
    }

    function startGame(count) {
        document.getElementById('turn-decide-screen').style.display = 'none';
        document.getElementById('ingame-ui').style.display = 'flex';
        points = []; lines = []; triangles = []; scores = { 1: 0, 2: 0 }; isGameOver = false; scoreEffects = [];
        const margin = 100;
        for (let i = 0; i < count; i++) {
            points.push({ x: Math.random() * (canvas.width - margin * 2) + margin, y: Math.random() * (canvas.height - margin * 2) + margin });
        }
        updateUI();
        drawLoop();
        if (currentPlayer === 2) setTimeout(aiMove, 600);
    }

    function handleInput(clientX, clientY) {
        if (currentPlayer !== 1 || isGameOver || aiAnimating || points.length === 0) return;
        const p = points.find(pt => Math.hypot(pt.x - clientX, pt.y - clientY) < 35);
        if (p && !selectedPoint) { selectedPoint = p; } 
        else if (p && selectedPoint !== p) {
            if (canConnect(selectedPoint, p)) { attemptMove(selectedPoint, p); selectedPoint = null; } 
            else { selectedPoint = null; }
        } else { selectedPoint = null; }
    }

    canvas.addEventListener('mousedown', (e) => handleInput(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', (e) => { handleInput(e.touches[0].clientX, e.touches[0].clientY); }, { passive: true });
    window.addEventListener('mousemove', (e) => { mousePos.x = e.clientX; mousePos.y = e.clientY; });

    function canConnect(p1, p2) {
        if (!p1 || !p2) return false;
        if (lines.some(l => (l.p1 === p1 && l.p2 === p2) || (l.p1 === p2 && l.p2 === p1))) return false;
        if (lines.some(l => isIntersecting(p1, p2, l.p1, l.p2))) return false;
        if (isPassingThroughPoint(p1, p2, points)) return false;
        return true;
    }
    function isIntersecting(p1, p2, p3, p4) {
        const cp = (a, b, c) => (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        const d1 = cp(p3, p4, p1); const d2 = cp(p3, p4, p2);
        const d3 = cp(p1, p2, p3); const d4 = cp(p1, p2, p4);
        return (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0)));
    }
    function isPassingThroughPoint(p1, p2, arr) {
        return arr.some(p => {
            if (p === p1 || p === p2) return false;
            const d12 = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const d1p = Math.hypot(p.x - p1.x, p.y - p1.y);
            const dp2 = Math.hypot(p.x - p2.x, p.y - p2.y);
            return Math.abs(d12 - (d1p + dp2)) < 1.0;
        });
    }

    function addScoreEffect() {
        scoreEffects.push({
            x: canvas.width / 2,
            y: canvas.height / 2,
            opacity: 1,
            life: 60 // ì•½ 1ì´ˆ ë™ì•ˆ ìœ ì§€
        });
    }

    function attemptMove(p1, p2) {
        lines.push({ p1, p2, player: currentPlayer });
        const bonus = checkTriangle(lines[lines.length-1]);
        if (bonus > 0) {
            scores[currentPlayer] += bonus;
            addScoreEffect(); // ë“ì  ì´í™íŠ¸ ì¶”ê°€
            updateUI(); if (!checkGameOver() && currentPlayer === 2) setTimeout(aiMove, 600);
        } else {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateUI(); if (currentPlayer === 2) setTimeout(aiMove, 800);
        }
    }

    function aiMove() {
        if (isGameOver) return;
        let moves = [];
        for (let i = 0; i < points.length; i++) {
            for (let j = i + 1; j < points.length; j++) {
                if (canConnect(points[i], points[j])) moves.push({ p1: points[i], p2: points[j] });
            }
        }
        if (moves.length > 0) {
            const scorers = moves.filter(m => willFormTriangle(m.p1, m.p2));
            const best = (aiLevel !== 'easy' && scorers.length > 0) ? scorers[0] : moves[Math.floor(Math.random()*moves.length)];
            aiStartPoint = best.p1; aiEndPoint = best.p2; aiAnimProgress = 0; aiAnimating = true;
        } else { checkGameOver(true); }
    }

    function willFormTriangle(p1, p2) {
        return points.some(p3 => {
            const h1 = lines.some(l => (l.p1===p1 && l.p2===p3) || (l.p1===p3 && l.p2===p1));
            const h2 = lines.some(l => (l.p1===p2 && l.p2===p3) || (l.p1===p3 && l.p2===p2));
            return h1 && h2;
        });
    }

    function checkTriangle(newLine) {
        let count = 0;
        points.forEach(p3 => {
            if (p3 === newLine.p1 || p3 === newLine.p2) return;
            const l1 = lines.find(l => (l.p1===newLine.p1 && l.p2===p3) || (l.p1===p3 && l.p2===newLine.p1));
            const l2 = lines.find(l => (l.p1===newLine.p2 && l.p2===p3) || (l.p1===p3 && l.p2===newLine.p2));
            if (l1 && l2) {
                if (!triangles.some(t => [t.p1, t.p2, t.p3].every(p => [newLine.p1, newLine.p2, p3].includes(p)))) {
                    triangles.push({ p1: newLine.p1, p2: newLine.p2, p3: p3, player: currentPlayer });
                    count++;
                }
            }
        });
        return count;
    }

    function updateUI() {
        document.getElementById('s1').innerText = scores[1];
        document.getElementById('s2').innerText = scores[2];
        const m = document.getElementById('mid-msg');
        m.innerText = currentPlayer === 1 ? "â—€ MY TURN" : "AI THINKING...";
        m.style.color = currentPlayer === 1 ? "#2ecc71" : "#e74c3c";
    }

    function checkGameOver(force = false) {
        let possible = force ? false : points.some((p1, i) => points.slice(i+1).some(p2 => canConnect(p1, p2)));
        if (!possible) {
            isGameOver = true;
            document.getElementById('winner-msg').innerText = scores[1] > scores[2] ? "í”Œë ˆì´ì–´ ìŠ¹ë¦¬!" : "AI ìŠ¹ë¦¬!";
            document.getElementById('game-over-screen').style.display = 'flex';
            return true;
        }
        return false;
    }

    function drawLoop() {
        if (isGameOver) return;
        ctx.fillStyle = "#0b0e14"; ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        triangles.forEach(t => {
            ctx.beginPath(); ctx.moveTo(t.p1.x, t.p1.y); ctx.lineTo(t.p2.x, t.p2.y); ctx.lineTo(t.p3.x, t.p3.y); ctx.closePath();
            ctx.fillStyle = t.player === 1 ? 'rgba(46, 204, 113, 0.2)' : 'rgba(231, 76, 60, 0.2)'; ctx.fill();
        });

        if (selectedPoint && !aiAnimating) {
            ctx.beginPath(); ctx.moveTo(selectedPoint.x, selectedPoint.y); ctx.lineTo(mousePos.x, mousePos.y);
            ctx.strokeStyle = "rgba(255,255,255,0.3)"; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
        }

        if (aiAnimating) {
            const curX = aiStartPoint.x + (aiEndPoint.x - aiStartPoint.x) * aiAnimProgress;
            const curY = aiStartPoint.y + (aiEndPoint.y - aiStartPoint.y) * aiAnimProgress;
            ctx.beginPath(); ctx.moveTo(aiStartPoint.x, aiStartPoint.y); ctx.lineTo(curX, curY);
            ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 3; ctx.stroke();
            aiAnimProgress += 0.05; if (aiAnimProgress >= 1) { aiAnimating = false; attemptMove(aiStartPoint, aiEndPoint); }
        }

        lines.forEach(l => {
            ctx.beginPath(); ctx.moveTo(l.p1.x, l.p1.y); ctx.lineTo(l.p2.x, l.p2.y);
            ctx.strokeStyle = l.player === 1 ? '#2ecc71' : '#e74c3c'; ctx.lineWidth = 3; ctx.stroke();
        });

        points.forEach(p => {
            ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = (selectedPoint === p) ? '#fff' : '#2c3e50'; ctx.fill();
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        });

        // ë“ì  ì´í™íŠ¸ ê·¸ë¦¬ê¸°
        for (let i = scoreEffects.length - 1; i >= 0; i--) {
            let eff = scoreEffects[i];
            ctx.font = "bold 40px 'Malgun Gothic'";
            ctx.fillStyle = `rgba(241, 196, 15, ${eff.opacity})`;
            ctx.textAlign = "center";
            ctx.fillText("+1 POINT", eff.x, eff.y);
            eff.y -= 1.5; // ìœ„ë¡œ ì´ë™
            eff.opacity -= 0.02; // ì ì  íˆ¬ëª…í•˜ê²Œ
            eff.life--;
            if (eff.life <= 0) scoreEffects.splice(i, 1);
        }
        
        requestAnimationFrame(drawLoop);
    }
</script>
</body>
</html>
