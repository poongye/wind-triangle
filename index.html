<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ìš°ì£¼ì „ìŸ v.0.1.8 - ì´ ì „ë ¥ ì§‘ê³„</title>
    <style>
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; background: #000; 
            font-family: 'Malgun Gothic', sans-serif; color: white; 
            -webkit-tap-highlight-color: transparent;
            touch-action: none; 
        }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 10; touch-action: none; }
        #fixed-ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; pointer-events: none; }
        .score-container { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-between; padding: 0 15px; box-sizing: border-box; }
        .score-box { pointer-events: auto; font-size: 13px; font-weight: bold; padding: 10px; background: rgba(0,0,0,0.85); border-radius: 8px; border: 1px solid #ffffff33; line-height: 1.5; min-width: 140px; }
        #timer-display { position: absolute; top: 85px; left: 50%; transform: translateX(-50%); font-size: 32px; font-weight: bold; color: #ff3e3e; text-shadow: 0 0 10px #000; }
        #turn-msg { position: absolute; top: 135px; left: 50%; transform: translateX(-50%); font-size: 18px; font-weight: bold; color: #00ffcc; text-shadow: 0 0 10px #000; width: 100%; text-align: center; }
        #countdown-msg { position: absolute; bottom: 85px; left: 50%; transform: translateX(-50%); font-size: 20px; font-weight: bold; color: #f1c40f; text-shadow: 0 0 10px #000; display:none; }
        #bottom-ctrl { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: none; gap: 10px; background: rgba(0,0,0,0.85); padding: 10px 20px; border-radius: 50px; border: 1px solid #00ffcc; pointer-events: auto; z-index: 200; }
        .ctrl-btn { color: white; background: rgba(255,255,255,0.1); border: 1px solid #3498db; padding: 6px 15px; border-radius: 20px; cursor: pointer; font-size: 12px; }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; z-index: 1000; background: rgba(0,0,0,0.9); pointer-events: auto; }
        .rank-card { background: #0f0f1e; padding: 25px; border-radius: 20px; border: 2px solid #3498db; width: 90%; max-width: 380px; text-align: center; max-height: 90vh; overflow-y: auto; }
        .start-btn { padding: 15px; font-size: 18px; font-weight: bold; background: #3498db; color: #fff; border: none; border-radius: 12px; cursor: pointer; width: 100%; margin-top: 10px; box-shadow: 0 0 15px #3498db; }
        .scenario-box { text-align: left; background: rgba(0, 255, 204, 0.05); padding: 15px; border-radius: 10px; font-size: 13px; line-height: 1.6; margin-bottom: 15px; color: #a0ffe0; border-left: 3px solid #00ffcc; }
        select, input[type=range] { width: 100%; margin-top: 5px; background: #111; color: white; border: 1px solid #3498db; padding: 8px; border-radius: 5px; }
        /* ì´ í”Œë ˆì´ ìœ ì € í‘œì‹œ */
        .total-users { margin-top: 20px; font-size: 11px; color: #3498db; opacity: 0.9; text-transform: uppercase; border-top: 1px solid rgba(52, 152, 219, 0.3); padding-top: 15px; }
        #total-count { font-weight: bold; color: #fff; font-size: 13px; }
    </style>
</head>
<body oncontextmenu="return false;">
    <canvas id="gameCanvas"></canvas>
    
    <div id="rule-screen" class="overlay">
        <div class="rank-card">
            <h2 style="color:#00ffcc; margin-bottom:5px;">ğŸŒ¬ï¸ ë°”ëŒì˜ í›„ì˜ˆ</h2>
            <p style="font-size:11px; color:#aaa; margin-bottom:15px;">v.0.1.8 | The Last Cluster</p>
            
            <div class="scenario-box">
                <b>[ì‚¬ë ¹ë¶€ ë¸Œë¦¬í•‘]</b><br>
                ê¸°ê³„ ì œêµ­ 'ë ‰ìŠ¤'ì˜ ì—°ì‚°ë ¥ì€ ë§¤ì‹œê°„ ê°•í•´ì§€ê³  ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ìš°ë¦¬ëŠ” í˜¼ìê°€ ì•„ë‹™ë‹ˆë‹¤. ìˆ˜ë§ì€ í’ì˜ˆë“¤ì´ ê±°ì³ ê°„ ì´ ì„±ì „ì—ì„œ ë‹¹ì‹ ì˜ ê¸°ë¡ì„ ìƒˆê¸°ì‹­ì‹œì˜¤.
            </div>

            <div style="text-align:left; padding:0 10px; font-size:13px;">
                <label>ğŸ¤– ì œêµ­êµ° ì§€ëŠ¥:</label> 
                <select id="ai-diff"><option value="1800">ì‰¬ì›€</option><option value="1200" selected>ë³´í†µ(ì§€ëŠ¥ ìƒí–¥)</option><option value="600">ì–´ë ¤ì›€(ê·¹ê°•)</option></select>
                <br><br>
                <label>âœ¨ ì„±ê³„ ê°œìˆ˜: <span id="sv">25</span>ê°œ</label> 
                <input type="range" id="star-count" min="15" max="35" value="25" oninput="document.getElementById('sv').innerText=this.value">
            </div>
            <button class="start-btn" onclick="startWithSound()">ì„±ê³„ ì§„ì…</button>
            
            <div class="total-users">
                ì„±ê³„ì— íˆ¬ì…ëœ ì´ ìœ ì € ìˆ˜<br>
                <span id="total-count">254,812</span> ëª…
            </div>
        </div>
    </div>

    <div id="result-screen" class="overlay" style="display:none;">
        <div class="rank-card">
            <h1 id="result-title" style="color:#ff3e3e; margin-bottom:10px;">ì‘ì „ ì¢…ë£Œ</h1>
            <div id="result-scenario" class="scenario-box" style="margin-bottom:20px; font-size:14px; text-align:center;"></div>
            <h2 id="final-score" style="color:white; font-size: 15px; line-height: 1.8; margin-bottom:20px;"></h2>
            <button class="start-btn" onclick="location.reload()">ìƒˆë¡œìš´ ì „ì„ ìœ¼ë¡œ</button>
        </div>
    </div>

    <div id="fixed-ui">
        <div class="score-container">
            <div class="score-box" style="color:#2ecc71; border-color:#2ecc71;">ì—°ë§¹ ì´ ë³‘ë ¥ :<br><span id="s1">0</span>ì–µ ëª…</div>
            <div class="score-box" style="color:#e74c3c; border-color:#e74c3c; text-align:right;">ì œêµ­ ì´ ë³‘ë ¥ :<br><span id="s2">0</span>ì–µ ëª…</div>
        </div>
        <div id="timer-display">10</div>
        <div id="turn-msg">ì£¼íŒŒìˆ˜ ë™ê¸°í™” ì¤‘...</div>
        <div id="countdown-msg"></div>
        <div id="bottom-ctrl">
            <button class="ctrl-btn" onclick="toggleBGM()">ğŸµ ì£¼íŒŒìˆ˜</button>
            <button class="ctrl-btn" onclick="location.reload()">í‡´ê°</button>
        </div>
    </div>

    <audio id="bgm" loop preload="auto"><source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-8.mp3" type="audio/mpeg"></audio>
    <audio id="snd-select" preload="auto"><source src="https://assets.mixkit.co/active_storage/sfx/2571/2571-preview.mp3" type="audio/mpeg"></audio>
    <audio id="snd-connect" preload="auto"><source src="https://assets.mixkit.co/active_storage/sfx/2568/2568-preview.mp3" type="audio/mpeg"></audio>
    <audio id="snd-capture-player" preload="auto"><source src="https://assets.mixkit.co/active_storage/sfx/1435/1435-preview.mp3" type="audio/mpeg"></audio>
    <audio id="snd-capture-ai" preload="auto"><source src="https://assets.mixkit.co/active_storage/sfx/2511/2511-preview.mp3" type="audio/mpeg"></audio>
    <audio id="snd-end" preload="auto"><source src="https://assets.mixkit.co/active_storage/sfx/1433/1433-preview.mp3" type="audio/mpeg"></audio>

<script>
    // [ì‹ ê·œ] ì´ ìœ ì € ìˆ˜ ì—…ë°ì´íŠ¸ ë¡œì§
    function updateTotalCount() {
        const countEl = document.getElementById('total-count');
        if(!countEl) return;
        let current = parseInt(countEl.innerText.replace(/,/g, ''));
        if(Math.random() > 0.7) { // 30% í™•ë¥ ë¡œ ìƒˆë¡œìš´ ìœ ì € ì¹´ìš´íŠ¸ ì¦ê°€ ì—°ì¶œ
            current += 1;
            countEl.innerText = current.toLocaleString();
        }
    }
    setInterval(updateTotalCount, 5000);

    /* ê²Œì„ ì½”ì–´ ë¡œì§ (ì§€ëŠ¥í˜• AI ë° ìŠ¤í¬ë¡¤ ë°©ì§€ í¬í•¨) */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const bgImg = new Image();
    bgImg.src = 'https://r.jina.ai/i/5688686e04d44439832267675e03222e';
    let bgLoaded = false; bgImg.onload = () => { bgLoaded = true; };

    let points=[], lines=[], triangles=[], selectedPoint=null, mousePos={x:0,y:0}, isDragging=false;
    let currentPlayer=1, scores={1:0, 2:0}, effects=[], isGameOver = false, turnTime = 10, timerInterval;
    let penaltyCount = {1:0, 2:0}, gameStarted = false, aiLevel = 1200;
    let aiAnim = { active: false, startP: null, targetP: null, progress: 0 };

    function playSnd(id, vol=0.5) {
        const s = document.getElementById(id);
        if(s) { s.currentTime = 0; s.volume = vol; s.play().catch(()=>{}); }
    }

    function startWithSound() {
        playSnd('bgm', 0.2);
        ['snd-select', 'snd-connect', 'snd-capture-player', 'snd-capture-ai', 'snd-end'].forEach(id => {
            const s = document.getElementById(id); s.play().then(()=> { s.pause(); s.currentTime=0; }).catch(()=>{});
        });
        aiLevel = parseInt(document.getElementById('ai-diff').value);
        let starCount = parseInt(document.getElementById('star-count').value);
        document.getElementById('rule-screen').style.display = 'none';
        document.getElementById('bottom-ctrl').style.display = 'flex';
        startGame(starCount);
    }

    function startGame(count) {
        resize();
        points = []; lines = []; triangles = []; scores = {1:0, 2:0}; penaltyCount = {1:0, 2:0};
        currentPlayer = Math.random() > 0.5 ? 1 : 2; 
        isGameOver = false; gameStarted = true;
        points.push({ x: canvas.width/2, y: canvas.height/2, isCore: true });
        for(let i=0; i<count-1; i++) {
            let nx, ny, ok;
            do {
                nx = 50 + Math.random() * (canvas.width - 100);
                ny = 150 + Math.random() * (canvas.height - 250);
                ok = points.every(p => Math.hypot(p.x - nx, p.y - ny) > 65);
            } while(!ok);
            points.push({ x: nx, y: ny, isCore: false });
        }
        updateTurnMsg(); startTimer(); updateUI(); 
        requestAnimationFrame(drawLoop);
        if(currentPlayer === 2) setTimeout(aiThink, 1500);
    }

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);

    function startTimer() {
        if(isGameOver) return;
        clearInterval(timerInterval); turnTime = 10;
        document.getElementById('timer-display').innerText = turnTime;
        timerInterval = setInterval(() => {
            turnTime--; 
            document.getElementById('timer-display').innerText = turnTime;
            if(turnTime <= 0) {
                penaltyCount[currentPlayer]++;
                let penaltyValue = penaltyCount[currentPlayer] * 50; 
                scores[currentPlayer] = Math.max(0, scores[currentPlayer] - penaltyValue);
                effects.push({x: canvas.width/2, y: 150, text: `âš ï¸ í•´í‚¹! -${penaltyValue}ì–µ`, color: "#ff3e3e", size: 22});
                playSnd('snd-capture-ai', 0.5);
                updateUI();
                clearInterval(timerInterval);
                setTimeout(nextTurn, 800);
            }
        }, 1000);
    }

    function attemptMove(p1, p2) {
        lines.push({p1, p2, player: currentPlayer}); 
        playSnd('snd-connect', 0.6);
        let foundThisTurn = false;
        let turnCombo = 0;
        points.forEach(p3 => {
            if(p3 === p1 || p3 === p2) return;
            const l1 = lines.find(l => (l.p1===p1 && l.p2===p3) || (l.p1===p3 && l.p2===p1));
            const l2 = lines.find(l => (l.p1===p2 && l.p2===p3) || (l.p1===p3 && l.p2===p2));
            const l3 = lines.find(l => (l.p1===p1 && l.p2===p2) || (l.p1===p2 && l.p2===p1)); 
            if(l1 && l2 && !triangles.some(t => [t.p1,t.p2,t.p3].every(p => [p1,p2,p3].includes(p)))) {
                triangles.push({p1, p2, p3, player: currentPlayer});
                turnCombo++; foundThisTurn = true;
                let myLines = [l1, l2, l3].filter(l => l.player === currentPlayer).length;
                let multiplier = myLines === 3 ? 1.0 : (myLines === 2 ? 0.8 : 0.5);
                let baseTroop = Math.floor(Math.abs((p1.x*(p2.y-p3.y) + p2.x*(p3.y-p1.y) + p3.x*(p1.y-p2.y)) / 100)) + 50; 
                let isCritical = Math.random() < 0.1;
                if(isCritical) multiplier *= 2.0;
                let finalTroop = Math.floor(baseTroop * multiplier) + (turnCombo > 1 ? turnCombo * 20 : 0);
                if(scores[currentPlayer === 1 ? 2 : 1] - scores[currentPlayer] > 500) finalTroop += 30;
                scores[currentPlayer] += finalTroop;
                let cx = (p1.x+p2.x+p3.x)/3, cy = (p1.y+p2.y+p3.y)/3;
                if(isCritical) effects.push({x: cx, y: cy-25, text: "ğŸŒ¬ï¸ ë°”ëŒì˜ ê°€í˜¸!!", color: "#f1c40f", size: 24});
                effects.push({x: cx, y: cy, text: `+${finalTroop}ì–µ`, color: currentPlayer==1?"#2ecc71":"#e74c3c", size: 16});
                playSnd(currentPlayer === 1 ? 'snd-capture-player' : 'snd-capture-ai', 0.7);
            }
        });
        if(!foundThisTurn) nextTurn(); else startTimer();
        updateUI(); checkGameOver();
    }

    function nextTurn() { 
        if(isGameOver) return;
        currentPlayer = currentPlayer === 1 ? 2 : 1; 
        updateTurnMsg(); startTimer(); updateUI(); 
        if(currentPlayer === 2) setTimeout(aiThink, aiLevel); 
        checkRemainingTerritories();
    }

    function aiThink() {
        if(isGameOver || currentPlayer !== 2) return;
        let moves = [];
        for(let i=0; i<points.length; i++) {
            for(let j=i+1; j<points.length; j++) {
                if(canConnect(points[i], points[j])) {
                    let weight = 0;
                    points.forEach(p3 => {
                        if(p3 === points[i] || p3 === points[j]) return;
                        const hasL1 = lines.some(l => (l.p1===points[i] && l.p2===p3) || (l.p1===p3 && l.p2===points[i]));
                        const hasL2 = lines.some(l => (l.p1===points[j] && l.p2===p3) || (l.p1===p3 && l.p2===points[j]));
                        if(hasL1 && hasL2) weight += 100;
                        if(hasL1 || hasL2) weight += 5;
                    });
                    moves.push({p1: points[i], p2: points[j], weight});
                }
            }
        }
        if(moves.length > 0) {
            moves.sort((a, b) => b.weight - a.weight);
            let choice = moves.slice(0, 3)[Math.floor(Math.random() * Math.min(3, moves.length))];
            aiAnim.startP = choice.p1; aiAnim.targetP = choice.p2; aiAnim.progress = 0; aiAnim.active = true;
        } else nextTurn();
    }

    function canConnect(p1, p2) {
        if(!p1 || !p2 || p1 === p2) return false;
        if(lines.some(l => (l.p1 === p1 && l.p2 === p2) || (l.p1 === p2 && l.p2 === p1))) return false;
        const isPass = points.some(p => {
            if (p === p1 || p === p2) return false;
            const d = Math.abs((p2.y - p1.y) * p.x - (p2.x - p1.x) * p.y + p2.x * p1.y - p2.y * p1.x) / Math.hypot(p2.y - p1.y, p2.x - p1.x);
            const dot = (p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y);
            return d < 8 && dot >= 0 && dot <= (Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        });
        if(isPass) return false;
        const intersect = (a,b,c,d) => {
            const cp = (p1,p2,p3) => (p2.x-p1.x)*(p3.y-p1.y)-(p2.y-p1.y)*(p3.x-p1.x);
            const r1 = cp(a,b,c), r2 = cp(a,b,d), r3 = cp(c,d,a), r4 = cp(c,d,b);
            return (((r1 > 0 && r2 < 0) || (r1 < 0 && r2 > 0)) && ((r3 > 0 && r4 < 0) || (r3 < 0 && r4 > 0)));
        };
        return !lines.some(l => intersect(p1, p2, l.p1, l.p2));
    }

    function checkRemainingTerritories() {
        let count = 0;
        for(let i=0; i<points.length; i++) {
            for(let j=i+1; j<points.length; j++) {
                if(canConnect(points[i], points[j])) {
                    points.forEach(p3 => {
                        if(p3 === points[i] || p3 === points[j]) return;
                        const l1 = lines.some(l => (l.p1===points[i] && l.p2===p3) || (l.p1===p3 && l.p2===points[i]));
                        const l2 = lines.some(l => (l.p1===points[j] && l.p2===p3) || (l.p1===p3 && l.p2===points[j]));
                        if(l1 && l2) count++;
                    });
                }
            }
        }
        const cdMsg = document.getElementById('countdown-msg');
        if(count > 0 && count <= 5) {
            cdMsg.innerText = `âš ï¸ í™•ë³´ ê°€ëŠ¥ ì˜í† : ${count}ê°œ ë‚¨ìŒ!`;
            cdMsg.style.display = 'block';
        } else { cdMsg.style.display = 'none'; }
    }

    function checkGameOver() {
        let moves = 0;
        for(let i=0; i<points.length; i++) for(let j=i+1; j<points.length; j++) if(canConnect(points[i], points[j])) moves++;
        if(moves === 0 && gameStarted) {
            isGameOver = true; clearInterval(timerInterval);
            playSnd('snd-end', 0.8);
            document.getElementById('countdown-msg').style.display = 'none';
            document.getElementById('final-score').innerHTML = `ì—°ë§¹: ${scores[1].toLocaleString()}ì–µ ëª…<br>ì œêµ­: ${scores[2].toLocaleString()}ì–µ ëª…`;
            const win = scores[1] > scores[2];
            document.getElementById('result-title').innerText = win ? "ìŠ¹ì „ë³´!" : "íŒ¨ì „ í†µë³´";
            document.getElementById('result-scenario').innerText = win ? "ë°”ëŒì˜ í›„ì˜ˆê°€ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤! ì„±ê³„ì— í‰í™”ê°€ ì°¾ì•„ì˜µë‹ˆë‹¤." : "ì„±ê³„ê°€ í•¨ë½ë˜ì—ˆìŠµë‹ˆë‹¤... ì€í•˜ê³„ëŠ” ê¸°ê³„ì— ì§€ë°°ë‹¹í•©ë‹ˆë‹¤.";
            document.getElementById('result-screen').style.display = 'flex';
        }
    }

    function updateTurnMsg() {
        const msg = document.getElementById('turn-msg');
        msg.innerText = currentPlayer === 1 ? "ğŸŒ¬ï¸ í’ì˜ˆ ì—°ë§¹ ì‘ì „ ì‹œê°„" : "ğŸ¤– ì œêµ­êµ° ë³‘ë ¥ ì´ë™ ì¤‘";
        msg.style.color = currentPlayer === 1 ? "#2ecc71" : "#e74c3c";
    }

    function updateUI() { 
        document.getElementById('s1').innerText = scores[1].toLocaleString(); 
        document.getElementById('s2').innerText = scores[2].toLocaleString(); 
    }

    function toggleBGM() { const b = document.getElementById('bgm'); if(b.paused) b.play(); else b.pause(); }

    function drawLoop() {
        if(!gameStarted) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if(bgLoaded) ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
        triangles.forEach(t => {
            ctx.beginPath(); ctx.moveTo(t.p1.x, t.p1.y); ctx.lineTo(t.p2.x, t.p2.y); ctx.lineTo(t.p3.x, t.p3.y); ctx.closePath();
            ctx.fillStyle = t.player === 1 ? 'rgba(46, 204, 113, 0.4)' : 'rgba(231, 76, 60, 0.4)';
            ctx.fill(); ctx.strokeStyle = t.player === 1 ? '#2ecc71' : '#e74c3c'; ctx.stroke();
        });
        if(isDragging && selectedPoint) {
            ctx.beginPath(); ctx.moveTo(selectedPoint.x, selectedPoint.y); ctx.lineTo(mousePos.x, mousePos.y);
            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)"; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
        }
        if(aiAnim.active) {
            aiAnim.progress += 0.05;
            let cx = aiAnim.startP.x + (aiAnim.targetP.x - aiAnim.startP.x) * aiAnim.progress;
            let cy = aiAnim.startP.y + (aiAnim.targetP.y - aiAnim.startP.y) * aiAnim.progress;
            ctx.beginPath(); ctx.moveTo(aiAnim.startP.x, aiAnim.startP.y); ctx.lineTo(cx, cy);
            ctx.strokeStyle = "rgba(231, 76, 60, 0.7)"; ctx.setLineDash([5, 5]); ctx.lineWidth = 2; ctx.stroke(); ctx.setLineDash([]);
            if(aiAnim.progress >= 1) { aiAnim.active = false; attemptMove(aiAnim.startP, aiAnim.targetP); }
        }
        lines.forEach(l => {
            ctx.beginPath(); ctx.moveTo(l.p1.x, l.p1.y); ctx.lineTo(l.p2.x, l.p2.y);
            ctx.strokeStyle = l.player === 1 ? '#2ecc71' : '#e74c3c'; ctx.lineWidth = 2; ctx.stroke();
        });
        points.forEach(p => {
            ctx.font = p.isCore ? "40px Arial" : "25px Arial"; ctx.textAlign = "center";
            ctx.fillStyle = "white"; ctx.fillText(p.isCore ? "â˜€ï¸" : "âœ¨", p.x, p.y+10);
            if(selectedPoint === p) { ctx.strokeStyle = "#00ffcc"; ctx.lineWidth = 2; ctx.strokeRect(p.x-22, p.y-22, 44, 44); }
        });
        for(let i = effects.length - 1; i >= 0; i--) {
            let e = effects[i]; ctx.fillStyle = e.color; ctx.font = `bold ${e.size}px Arial`; ctx.textAlign = "center";
            ctx.fillText(e.text, e.x, e.y); e.y -= 1.0; if(e.y < 0) effects.splice(i, 1);
        }
        requestAnimationFrame(drawLoop);
    }

    const hStart = (x, y) => { 
        if(currentPlayer !== 1 || isGameOver || aiAnim.active) return; 
        const p = points.find(pt => Math.hypot(pt.x - x, pt.y - y) < 40); 
        if(p) { selectedPoint = p; isDragging = true; mousePos = {x, y}; playSnd('snd-select', 0.4); } 
    };
    const hMove = (x, y) => { if(isDragging) mousePos = {x, y}; };
    const hEnd = (x, y) => { 
        if(!isDragging) return; 
        const p = points.find(pt => Math.hypot(pt.x - x, pt.y - y) < 40); 
        if(p && p !== selectedPoint && canConnect(selectedPoint, p)) attemptMove(selectedPoint, p); 
        selectedPoint = null; isDragging = false; 
    };
    canvas.addEventListener('mousedown', e => hStart(e.clientX, e.clientY));
    window.addEventListener('mousemove', e => hMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', e => hEnd(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', e => { const t = e.touches[0]; hStart(t.clientX, t.clientY); e.preventDefault(); }, {passive:false});
    window.addEventListener('touchmove', e => { const t = e.touches[0]; hMove(t.clientX, t.clientY); e.preventDefault(); }, {passive:false});
    window.addEventListener('touchend', e => { const t = e.changedTouches[0]; hEnd(t.clientX, t.clientY); });
</script>
</body>
</html>
