<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë°”ëŒì˜ ì‚¼ê°í˜• - poongye Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0b0e14; font-family: 'Malgun Gothic', sans-serif; color: white; touch-action: none; }
        canvas { display: block; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(11, 14, 20, 0.95); z-index: 100; text-align: center; padding: 20px; box-sizing: border-box; }
        
        /* ê·œì¹™ ì„¤ëª…ì°½ ì „ìš© ìŠ¤íƒ€ì¼ */
        .rule-card { background: rgba(44, 62, 80, 0.8); padding: 30px; border-radius: 20px; border: 2px solid #f1c40f; max-width: 400px; line-height: 1.6; box-shadow: 0 0 30px rgba(241, 196, 15, 0.2); }
        .rule-card h2 { color: #f1c40f; margin-top: 0; }
        .rule-list { text-align: left; display: inline-block; margin: 20px 0; font-size: 15px; color: #ecf0f1; }
        .rule-list li { margin-bottom: 10px; }

        h1 { font-size: 36px; color: #f1c40f; text-shadow: 0 0 20px #f1c40f; margin-bottom: 20px; }
        .menu-btn { padding: 15px; margin: 8px; font-size: 18px; font-weight: bold; border: 2px solid #2ecc71; background: transparent; color: #2ecc71; border-radius: 50px; cursor: pointer; transition: 0.2s; width: 80%; max-width: 300px; }
        .menu-btn:hover { background: #2ecc71; color: white; transform: scale(1.05); }
        .btn-normal { border-color: #3498db; color: #3498db; } 
        .btn-hard { border-color: #e74c3c; color: #e74c3c; } 
        .btn-count { border-color: #f1c40f; color: #f1c40f; }
        
        #ingame-ui { position: absolute; top: 0; left: 0; width: 100%; pointer-events: none; display: flex; justify-content: space-between; padding: 15px; box-sizing: border-box; z-index: 50; }
        .score-box { font-size: 18px; font-weight: bold; transition: transform 0.2s; }
        .score-up { transform: scale(1.3); }
        .p1-ui { color: #2ecc71; text-shadow: 0 0 5px #2ecc71; } 
        .p2-ui { color: #e74c3c; text-shadow: 0 0 5px #e74c3c; }
        .turn-box { font-size: 30px; font-weight: 900; padding: 15px; border-radius: 10px; transition: 0.1s; border: 2px solid transparent; }
        .active-turn { background: white; color: black; box-shadow: 0 0 15px white; border-color: white; }
    </style>
</head>
<body>

    <audio id="bgm" loop><source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg"></audio>

    <div id="rule-screen" class="overlay">
        <h1>ğŸŒ¬ï¸ ë°”ëŒì˜ ì‚¼ê°í˜•</h1>
        <div class="rule-card">
            <h2>ğŸ“œ ê²Œì„ ê·œì¹™</h2>
            <ul class="rule-list">
                <li>ğŸ“ ë‘ ì ì„ í„°ì¹˜/í´ë¦­í•˜ì—¬ <b>ì„ </b>ì„ ê¸‹ìŠµë‹ˆë‹¤.</li>
                <li>ğŸš« ì„ ì€ <b>ë‹¤ë¥¸ ì„ </b>ì´ë‚˜ <b>ì¤‘ê°„ì˜ ì </b>ì„ í†µê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</li>
                <li>ğŸ“ ì‚¼ê°í˜•ì„ ì™„ì„±í•˜ë©´ <b>1ì </b>ì„ ì–»ê³  <b>í•œ ë²ˆ ë”!</b></li>
                <li>ğŸ ë” ê·¸ì„ ì„ ì´ ì—†ìœ¼ë©´ ì ìˆ˜ê°€ ë†’ì€ ìª½ì´ ìŠ¹ë¦¬!</li>
            </ul>
        </div>
        <button class="menu-btn" onclick="showDifficulty()">ì•Œê² ì–´! ì‹œì‘í•˜ì</button>
    </div>

    <div id="difficulty-screen" class="overlay" style="display:none;">
        <h1>ë‚œì´ë„ ì„ íƒ</h1>
        <button class="menu-btn" onclick="selectDifficulty('easy')">EASY</button>
        <button class="menu-btn btn-normal" onclick="selectDifficulty('normal')">NORMAL</button>
        <button class="menu-btn btn-hard" onclick="selectDifficulty('hard')">HARD</button>
    </div>

    <div id="count-screen" class="overlay" style="display:none;">
        <h1>ì ì˜ ê°œìˆ˜</h1>
        <button class="menu-btn btn-count" onclick="selectPointCount(10)">10ê°œ (ë¹ ë¦„)</button>
        <button class="menu-btn btn-count" onclick="selectPointCount(20)">20ê°œ (ë³´í†µ)</button>
        <button class="menu-btn btn-count" onclick="selectPointCount(30)">30ê°œ (ë³µì¡)</button>
    </div>

    <div id="turn-decide-screen" class="overlay" style="display:none;">
        <h2 id="turn-title">ì„ ê³µ ê²°ì • ì¤‘...</h2>
        <div style="display: flex; gap: 20px; margin-top: 20px;">
            <div id="slot-p1" class="turn-box p1-ui">USER</div>
            <div id="slot-p2" class="turn-box p2-ui">AI</div>
        </div>
    </div>

    <div id="ingame-ui" style="display:none;">
        <div id="p1-score-ui" class="score-box p1-ui">USER: <span id="s1">0</span></div>
        <div id="mid-msg" style="text-align: center;"></div>
        <div id="p2-score-ui" class="score-box p2-ui">AI: <span id="s2">0</span></div>
    </div>

    <div id="game-over-screen" class="overlay" style="display:none;">
        <h1 style="color: #f1c40f;">GAME OVER</h1>
        <div id="winner-msg" style="font-size: 20px; margin-bottom: 20px;"></div>
        <button class="menu-btn" onclick="location.reload()">ë‹¤ì‹œ í•˜ê¸°</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let audioCtx;
    
    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    let points = [], lines = [], triangles = [], selectedPoint = null, currentPlayer = 0, scores = {1:0, 2:0}, isGameOver = false, aiLevel, pointCount;
    let mousePos = { x: 0, y: 0 }, aiAnimating = false, aiStartPoint, aiEndPoint, aiAnimProgress = 0;

    // --- í™”ë©´ ì „í™˜ ë¡œì§ ---
    function showDifficulty() {
        initAudio();
        document.getElementById('rule-screen').style.display = 'none';
        document.getElementById('difficulty-screen').style.display = 'flex';
    }

    function selectDifficulty(l) { 
        aiLevel = l; 
        document.getElementById('bgm').play().catch(()=>{}); 
        document.getElementById('difficulty-screen').style.display = 'none'; 
        document.getElementById('count-screen').style.display = 'flex'; 
    }

    function selectPointCount(c) { 
        pointCount = c; 
        document.getElementById('count-screen').style.display = 'none'; 
        decideTurn(); 
    }

    // --- ì´í•˜ í•µì‹¬ ê²Œì„ ë¡œì§ (ê¸°ì¡´ê³¼ ë™ì¼í•˜ë˜ ìµœì í™”) ---
    function playTone(f, t, d, gVal = 0.05) {
        if (!audioCtx) return;
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
        o.type = t; o.frequency.setValueAtTime(f, audioCtx.currentTime);
        g.gain.setValueAtTime(gVal, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + d);
        o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + d);
    }
    const soundSuccess = () => playTone(600, 'sine', 0.1);
    const soundFail = () => playTone(150, 'sawtooth', 0.2, 0.1);
    const soundScoreAction = () => { playTone(880, 'sine', 0.1, 0.1); setTimeout(() => playTone(1320, 'sine', 0.15, 0.08), 50); };
    const speak = (t) => { const m = new SpeechSynthesisUtterance(t); m.lang = 'ko-KR'; m.rate = 1.3; window.speechSynthesis.speak(m); };

    function decideTurn() {
        document.getElementById('turn-decide-screen').style.display = 'flex';
        let count = 0, currentSlot = 1;
        const interval = setInterval(() => {
            document.getElementById('slot-p1').classList.remove('active-turn');
            document.getElementById('slot-p2').classList.remove('active-turn');
            currentSlot = currentSlot === 1 ? 2 : 1;
            document.getElementById('slot-p' + currentSlot).classList.add('active-turn');
            if (++count > 15) {
                clearInterval(interval);
                currentPlayer = Math.random() > 0.5 ? 1 : 2;
                document.getElementById('slot-p1').classList.toggle('active-turn', currentPlayer === 1);
                document.getElementById('slot-p2').classList.toggle('active-turn', currentPlayer === 2);
                document.getElementById('turn-title').innerText = (currentPlayer === 1 ? "USER" : "AI") + " ì„ ê³µ!";
                setTimeout(startGame, 1000);
            }
        }, 100);
    }

    function startGame() {
        document.getElementById('turn-decide-screen').style.display = 'none';
        document.getElementById('ingame-ui').style.display = 'flex';
        points = []; lines = []; triangles = []; scores = { 1: 0, 2: 0 }; isGameOver = false;
        const margin = 60;
        for (let i = 0; i < pointCount; i++) {
            points.push({ x: Math.random() * (canvas.width - margin * 2) + margin, y: Math.random() * (canvas.height - margin * 3) + margin * 1.5 });
        }
        updateUI();
        requestAnimationFrame(drawLoop);
        if (currentPlayer === 2) setTimeout(aiMove, 800);
    }

    function handleInput(clientX, clientY) {
        if (currentPlayer !== 1 || isGameOver || aiAnimating || points.length === 0) return;
        const p = points.find(pt => Math.hypot(pt.x - clientX, pt.y - clientY) < 30);
        if (p && !selectedPoint) { selectedPoint = p; soundSuccess(); } 
        else if (p && selectedPoint !== p) {
            if (!canConnect(selectedPoint, p)) { soundFail(); selectedPoint = null; } 
            else { attemptMove(selectedPoint, p); selectedPoint = null; }
        } else { selectedPoint = null; }
    }

    canvas.addEventListener('mousedown', (e) => handleInput(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    window.addEventListener('mousemove', (e) => { mousePos.x = e.clientX; mousePos.y = e.clientY; });
    window.addEventListener('touchmove', (e) => { mousePos.x = e.touches[0].clientX; mousePos.y = e.touches[0].clientY; }, { passive: false });

    function canConnect(p1, p2) {
        if (!p1 || !p2) return false;
        if (lines.some(l => (l.p1 === p1 && l.p2 === p2) || (l.p1 === p2 && l.p2 === p1))) return false;
        if (lines.some(l => isIntersecting(p1, p2, l.p1, l.p2))) return false;
        if (isPassingThroughPoint(p1, p2, points)) return false;
        return true;
    }
    function isIntersecting(p1, p2, p3, p4) {
        const cp = (a, b, c) => (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
        const d1 = cp(p3, p4, p1); const d2 = cp(p3, p4, p2);
        const d3 = cp(p1, p2, p3); const d4 = cp(p1, p2, p4);
        return (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0)));
    }
    function isPassingThroughPoint(p1, p2, arr) {
        return arr.some(p => {
            if (p === p1 || p === p2) return false;
            const d12 = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const d1p = Math.hypot(p.x - p1.x, p.y - p1.y);
            const dp2 = Math.hypot(p.x - p2.x, p.y - p2.y);
            return Math.abs(d12 - (d1p + dp2)) < 1.0;
        });
    }

    function attemptMove(p1, p2) {
        lines.push({ p1, p2, player: currentPlayer });
        const bonus = checkTriangle(lines[lines.length-1]);
        if (bonus > 0) {
            scores[currentPlayer] += bonus; soundScoreAction(); 
            const ui = document.getElementById(`p${currentPlayer}-score-ui`);
            ui.classList.add('score-up'); setTimeout(() => ui.classList.remove('score-up'), 200);
            updateUI(); if (!checkGameOver() && currentPlayer === 2) setTimeout(aiMove, 600);
        } else {
            soundSuccess(); currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateUI(); if (currentPlayer === 2) setTimeout(aiMove, 1000);
        }
    }

    function aiMove() {
        if (isGameOver) return;
        let moves = [];
        for (let i = 0; i < points.length; i++) {
            for (let j = i + 1; j < points.length; j++) {
                if (canConnect(points[i], points[j])) moves.push({ p1: points[i], p2: points[j] });
            }
        }
        if (moves.length > 0) {
            const scorers = moves.filter(m => willFormTriangle(m.p1, m.p2));
            const best = (aiLevel !== 'easy' && scorers.length > 0) ? scorers[0] : moves[Math.floor(Math.random()*moves.length)];
            aiStartPoint = best.p1; aiEndPoint = best.p2; aiAnimProgress = 0; aiAnimating = true;
        } else { checkGameOver(true); }
    }

    function willFormTriangle(p1, p2) {
        return points.some(p3 => {
            const h1 = lines.some(l => (l.p1===p1 && l.p2===p3) || (l.p1===p3 && l.p2===p1));
            const h2 = lines.some(l => (l.p1===p2 && l.p2===p3) || (l.p1===p3 && l.p2===p2));
            return h1 && h2;
        });
    }

    function checkTriangle(newLine) {
        let count = 0;
        points.forEach(p3 => {
            if (p3 === newLine.p1 || p3 === newLine.p2) return;
            const l1 = lines.find(l => (l.p1===newLine.p1 && l.p2===p3) || (l.p1===p3 && l.p2===newLine.p1));
            const l2 = lines.find(l => (l.p1===newLine.p2 && l.p2===p3) || (l.p1===p3 && l.p2===newLine.p2));
            if (l1 && l2) {
                if (!triangles.some(t => [t.p1, t.p2, t.p3].every(p => [newLine.p1, newLine.p2, p3].includes(p)))) {
                    triangles.push({ p1: newLine.p1, p2: newLine.p2, p3: p3, player: currentPlayer });
                    count++;
                }
            }
        });
        return count;
    }

    function updateUI() {
        document.getElementById('s1').innerText = scores[1];
        document.getElementById('s2').innerText = scores[2];
        const m = document.getElementById('mid-msg');
        m.innerText = currentPlayer === 1 ? "â—€ MY TURN" : "AI THINKING...";
        m.style.color = currentPlayer === 1 ? "#2ecc71" : "#e74c3c";
    }

    function checkGameOver(force = false) {
        let possible = force ? false : points.some((p1, i) => points.slice(i+1).some(p2 => canConnect(p1, p2)));
        if (!possible) {
            isGameOver = true;
            const res = scores[1] > scores[2] ? "ìŠ¹ë¦¬! ğŸ‰" : (scores[1] === scores[2] ? "ë¬´ìŠ¹ë¶€ ğŸ¤" : "íŒ¨ë°°.. ğŸ¤–");
            speak("ê²Œì„ ì¢…ë£Œ. ê²°ê³¼ëŠ” " + res);
            document.getElementById('winner-msg').innerText = "ìµœì¢… ê²°ê³¼: " + res;
            document.getElementById('game-over-screen').style.display = 'flex';
            return true;
        }
        return false;
    }

    function drawLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        triangles.forEach(t => {
            ctx.beginPath(); ctx.moveTo(t.p1.x, t.p1.y); ctx.lineTo(t.p2.x, t.p2.y); ctx.lineTo(t.p3.x, t.p3.y); ctx.closePath();
            ctx.fillStyle = t.player === 1 ? 'rgba(46, 204, 113, 0.2)' : 'rgba(231, 76, 60, 0.2)'; ctx.fill();
        });
        if (selectedPoint && !isGameOver && !aiAnimating) {
            const blocked = !canConnect(selectedPoint, mousePos);
            ctx.beginPath(); ctx.moveTo(selectedPoint.x, selectedPoint.y); ctx.lineTo(mousePos.x, mousePos.y);
            ctx.strokeStyle = blocked ? 'rgba(231, 76, 60, 0.8)' : 'rgba(255, 255, 255, 0.4)';
            ctx.setLineDash([5, 5]); ctx.lineWidth = 2; ctx.stroke(); ctx.setLineDash([]);
        }
        if (aiAnimating) {
            const curX = aiStartPoint.x + (aiEndPoint.x - aiStartPoint.x) * aiAnimProgress;
            const curY = aiStartPoint.y + (aiEndPoint.y - aiStartPoint.y) * aiAnimProgress;
            ctx.beginPath(); ctx.moveTo(aiStartPoint.x, aiStartPoint.y); ctx.lineTo(curX, curY);
            ctx.strokeStyle = 'rgba(231, 76, 60, 0.6)'; ctx.setLineDash([5, 5]); ctx.lineWidth = 3; ctx.stroke(); ctx.setLineDash([]);
            aiAnimProgress += 0.04;
            if (aiAnimProgress >= 1) { aiAnimating = false; attemptMove(aiStartPoint, aiEndPoint); }
        }
        lines.forEach(l => {
            ctx.beginPath(); ctx.moveTo(l.p1.x, l.p1.y); ctx.lineTo(l.p2.x, l.p2.y);
            ctx.strokeStyle = l.player === 1 ? '#2ecc71' : '#e74c3c'; ctx.lineWidth = 3; ctx.stroke();
        });
        points.forEach(p => {
            ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = (selectedPoint === p) ? '#fff' : '#2c3e50'; ctx.fill();
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        });
        if (!isGameOver) requestAnimationFrame(drawLoop);
    }
</script>
</body>
</html>
